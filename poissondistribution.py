# -*- coding: utf-8 -*-
"""PoissonDistribution.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sSZzacLt8gFv5UD-AZMbPqkYcIp9WapY
"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans

# Function to generate multi-dimensional data with multiple classes
def generate_multi_class_data(n_classes, n_features, n_samples_per_class, std_dev, dist_type='normal'):
    """
    Generates data with multiple classes and features.

    Parameters:
    n_classes (int): Number of classes to generate.
    n_features (int): Number of features for each data point.
    n_samples_per_class (int): Number of samples per class.
    std_dev (float): Standard deviation for the normal distribution.
    dist_type (str): Type of distribution to use ('normal', 'uniform', 'poisson').

    Returns:
    X (numpy.ndarray): The generated data.
    y (numpy.ndarray): The corresponding class labels.
    """
    # Generate class centers
    class_centers = np.random.rand(n_classes, n_features) * 10

    # Generate data points for each class
    X = []
    y = []
    for i in range(n_classes):
        if dist_type == 'normal':
            class_samples = np.random.normal(class_centers[i], std_dev, (n_samples_per_class, n_features))
        elif dist_type == 'uniform':
            class_samples = np.random.uniform(-5, 5, (n_samples_per_class, n_features))
        elif dist_type == 'poisson':
            class_samples = np.random.poisson(class_centers[i], (n_samples_per_class, n_features))
        else:
            raise ValueError("Invalid distribution type. Use 'normal', 'uniform', or 'poisson'.")
        X.extend(class_samples)
        y.extend([i] * n_samples_per_class)

    return np.array(X), np.array(y)

# Generate data with 3 classes and 3 features
n_classes = 3
n_features = 3
n_samples_per_class = 200
std_dev = 1.0

# Generate data with normal distribution
X_normal, y_normal = generate_multi_class_data(n_classes, n_features, n_samples_per_class, std_dev, 'normal')

# Generate data with uniform distribution
X_uniform, y_uniform = generate_multi_class_data(n_classes, n_features, n_samples_per_class, std_dev, 'uniform')

# Generate data with Poisson distribution
X_poisson, y_poisson = generate_multi_class_data(n_classes, n_features, n_samples_per_class, std_dev, 'poisson')

# Visualize the data
fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(18, 5))

# Plot the data with normal distribution
ax1.scatter(X_normal[:, 0], X_normal[:, 1], c=y_normal)
ax1.set_title("Data with Normal Distribution")
ax1.set_xlabel("Feature 1")
ax1.set_ylabel("Feature 2")

# Plot the data with uniform distribution
ax2.scatter(X_uniform[:, 0], X_uniform[:, 1], c=y_uniform)
ax2.set_title("Data with Uniform Distribution")
ax2.set_xlabel("Feature 1")
ax2.set_ylabel("Feature 2")

# Plot the data with Poisson distribution
ax3.scatter(X_poisson[:, 0], X_poisson[:, 1], c=y_poisson)
ax3.set_title("Data with Poisson Distribution")
ax3.set_xlabel("Feature 1")
ax3.set_ylabel("Feature 2")

plt.show()

# Cluster the data using KMeans
kmeans_normal = KMeans(n_clusters=n_classes)
kmeans_normal.fit(X_normal)
kmeans_labels_normal = kmeans_normal.labels_

kmeans_uniform = KMeans(n_clusters=n_classes)
kmeans_uniform.fit(X_uniform)
kmeans_labels_uniform = kmeans_uniform.labels_

kmeans_poisson = KMeans(n_clusters=n_classes)
kmeans_poisson.fit(X_poisson)
kmeans_labels_poisson = kmeans_poisson.labels_

# Calculate accuracy for normal distribution
accuracy_normal = np.sum(kmeans_labels_normal == y_normal) / len(y_normal)
print("Accuracy for Normal Distribution:", accuracy_normal)

# Calculate accuracy for uniform distribution
accuracy_uniform = np.sum(kmeans_labels_uniform == y_uniform) / len(y_uniform)
print("Accuracy for Uniform Distribution:", accuracy_uniform)

# Calculate accuracy for Poisson distribution
accuracy_poisson = np.sum(kmeans_labels_poisson == y_poisson) / len(y_poisson)
print("Accuracy for Poisson Distribution:", accuracy_poisson)